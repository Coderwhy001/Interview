# 浏览器包含了哪些进程
- 主进程
1. 协调控制其他子进程
2. 浏览器界面显示， 用户交互，前进，后退，收藏
- 第三方插件进程
1. 每种类型的插件对应一个进程， 仅当使用该插件时才创建
- GPU进程
用于3D绘制
- 渲染进程， 就是我们说的浏览器内核
1. 负责页面渲染， 脚本执行， 事件处理等
2. 每个tab页一个渲染进程
# 浏览器内核（渲染进程）
从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。
而对于渲染进程来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。
- GUI渲染线程
1. 负责渲染页面， 布局和绘制
2. 页面需要重绘和回流时， 该线程就会执行
3. 与s引擎线程互斥， 防止渲染结果不可预期
- JS引擎线程
1. 负责处理解析和执行javascript脚本程序
2. 只有一个JS引擎线程(单线程)
3. 与GUI渲染线程互斥， 防止渲染结果不可预期
- 事件触发线程
1. 用来控制事件循环(鼠标点击， setTimeOut， ajax)
2. 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
- 定时触发器线程
1. setInterval与setTimeout所在的线程
2. 定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
3. 计时完毕后，通知事件触发线程
- 异步http请求线程
1. 浏览器有一个单独的线程用于处理AJAX请求
2. 当请求完成时，若有回调函数，通知事件触发线程
当我们了解了渲染进程包含的这些线程后，我们思考两个问题：

1. 为什么 javascript 是单线程的
2. 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥

## 为什么javascript是单线程
首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。
其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。
而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。
## 为什么 GUI 渲染线程与 JS 引擎线程互斥
这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，
那么渲染线程前后获得的元素就可能不一致了。
因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI渲染线程和JS引擎线程为互斥关系，
当JS引擎线程执行时GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。
## EventLoop
- JS引擎线程只执行执行栈中的事件
- 执行栈中的代码执行完毕，就会读取事件队列中的事件
- 事件队列中的回调事件，是由各自线程插入到事件队列中的
- 如此循环
## 宏任务， 微任务
### 宏任务
我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)，每一个宏任务会从头到尾执行完毕，不会执行其他。

我们前文提到过JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个`宏任务`执行前，GUI渲染线程开始工作，对页面进行渲染。
```
// 宏任务-->渲染-->宏任务-->渲染-->渲染．．．
```
主代码块，setTimeout，setInterval等，都属于宏任务
### 微任务
我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务。
也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完。
Promise，process.nextTick等，属于微任务。
