# 输入url到页面渲染做了什么？
1. 用户在地址栏输入url，这时浏览器进程会判断url是否完整，组装协议，而后通过ipc通信把完整的url传给网络进程
2. 首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。
3. 而后网络进程查看是否有dns缓存，如果没有就在dns系统查找对应的ip地址，如果是https，还会建立TLS连接
4. 接下来就是利用ip地址和服务器建立tcp连接， 连接建立之后，浏览器会构建请求行，请求头和请求体，并把该域名相关的cookie等信息添加到请求头中，发起http请求
5. 服务器接收请求之后，会返回响应数据并且发给网络进程，而后网络进程开始解析响应数据
6. 若状态码是301或302，则重定向到响应数据location页面，若是200则正常解析
7. 如果content-type是text/html的话，需要准备渲染进程，若这个页面的请求和上一个页面的根域名一样，则会复用上一个页面的渲染进程，若不是或代码禁止复用，则打开新的渲染进程
8. 网络进程会把返回的html文档提交给渲染进程，若数据传输完毕，浏览器更新页面，url等状态
9. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
10. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
11. 创建布局树，并计算元素的布局信息。
12. 对布局树进行分层，并生成分层树。
13. 为每个图层生成绘制列表，并将其提交到合成线程。 
14. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
15. 合成线程发送绘制图块命令DrawQuad给浏览器进程。 
16. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
# transform为什么相比position更不耗

# 尾递归优化
若函数的最后一步操作是调用函数，则将这种递归称为尾递归，目前大部分编译器都对尾递归有优化，会将当前函数的执行上下文从调用栈中清除然后创建下一个执行上下文，不会造成栈溢出
# let 和var区别
let会在创建时被提升，这时会在词法环境创建这个变量，但是不会初始化，所以处于暂时性死区， var的创建和初始化都被提升，复制undefined，并且在编译时就会被创建到编译环境中，只要处于函数的执行上下文，先访问词法环境再访问变量环境
# 闭包
当一个函数返回另一个函数，而返回的函数又引用到了第一个函数的变量时，就形成了闭包，这时外层函数执行完毕后执行上下文会从调用栈中销毁，但是所引用到的变量会形成闭包，所以当返回的函数中需要改变引用的变量时，会改变闭包中的变量。闭包产生的内存对象地址存储在栈中，数据存储在堆中，当函数销毁时不会跟着销毁，因为还有引用。
# setTimeOut中的回调函数的this是指向windows对象的