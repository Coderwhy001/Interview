# 输入url到页面渲染做了什么？
1. 用户在地址栏输入url，这时浏览器进程会判断url是否完整，组装协议，而后通过ipc通信把完整的url传给网络进程
2. 首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。
3. 而后网络进程查看是否有dns缓存，如果没有就在dns系统查找对应的ip地址，如果是https，还会建立TLS连接
4. 接下来就是利用ip地址和服务器建立tcp连接， 连接建立之后，浏览器会构建请求行，请求头和请求体，并把该域名相关的cookie等信息添加到请求头中，发起http请求
5. 服务器接收请求之后，会返回响应数据并且发给网络进程，而后网络进程开始解析响应数据
6. 若状态码是301或302，则重定向到响应数据location页面，若是200则正常解析
7. 如果content-type是text/html的话，需要准备渲染进程，由于站点隔离，所以跟域名一样的页面会被放到同一个渲染进程，而如果一个页面存在不同站点的iframe或者新的页面根域名不同，也会被放到新的渲染进程中
8. 网络进程会把返回的html文档提交给渲染进程，若数据传输完毕，浏览器更新页面，url等状态
9. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
10. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
11. 创建布局树，并计算元素的布局信息。
12. 对布局树进行分层，并生成分层树。
13. 为每个图层生成绘制列表，并将其提交到合成线程。 
14. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
15. 合成线程发送绘制图块命令DrawQuad给浏览器进程。 
16. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
# transform为什么相比position更不耗性能
因为transform是触发合成，position触发重排

# 尾递归优化
若函数的最后一步操作是调用函数，则将这种递归称为尾递归，目前大部分编译器都对尾递归有优化，会将当前函数的执行上下文从调用栈中清除然后创建下一个执行上下文，不会造成栈溢出
# let 和var区别
let会在创建时被提升，这时会在词法环境创建这个变量，但是不会初始化，所以处于暂时性死区， var的创建和初始化都被提升，复制undefined，并且在编译时就会被创建到变量环境中，只要处于函数的执行上下文，先访问词法环境再访问变量环境
# 闭包
当一个函数返回另一个函数，而返回的函数又引用到了第一个函数的变量时，就形成了闭包，这时外层函数执行完毕后执行上下文会从调用栈中销毁，但是所引用到的变量会形成闭包，所以当返回的函数中需要改变引用的变量时，会改变闭包中的变量。闭包产生的内存对象地址存储在栈中，数据存储在堆中，当函数销毁时不会跟着销毁，因为还有引用。
# dns查找方式
# 有etag为什么还要lastmodefined
# setTimeOut中的回调函数的this是指向windows对象的
# 页面渲染性能优化策略
1. 减少 JavaScript 脚本执行时间
- 可以将一个很大的任务分成多个小任务
- 使用web workers，web workers是运行在主线程之外的一个线程，web workers没有DOM和CSSOM的环境，所以可以把一些与dom无关且不耗时的任务放在这里运行
2. 避免强制布局或者布局抖动
由于浏览器会对一系列重拍操作添加到队列中，队列满了会将其一次性执行，这样避免多次重拍操作，但是如果我们在进行了重排操作后需要获取位置信息如offset， 这时浏览器判定队列有操作，需要清空队列来获取正确的信息，这样会导致多次重排，影响页面性能
3. 合理利用 CSS 合成动画
尽量避免用js实现动画，因为合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。
4. 避免频繁的垃圾回收
我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。
# http1.1和2.0的区别
1. http1.1虽然实现了持久化连接，6个tcp连接和cdn域名分片，但是有几大问题
- tcp连接慢。慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。
- 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。
- 头部阻塞。持久连接可以公用一个管道，但是一个tcp中前一个请求网络阻塞了，后面那个需要等待，很耗时间
2. http2的改进
- 多路复用： 一个域名只是用一个tcp连接，每个请求多复用这个tcp连接，这样不用重复的建立tcp连接，只连接一次，并且解决了头部阻塞和共享带宽的问题
- 可以设置请求的优先级：由于服务器是按照请求的顺序回复数据，有些重要的数据会推迟，所以设置优先级使他第一时间到达
- 服务器推送：服务器支持像浏览器推送数据
- 头部压缩： 如果http发现多个请求的头部大部分内容一致，可以将其省略，这样只保留不一致的内容
但是由于http只有一个tcp连接，如果这个tcp连接出现了数据包的丢失，那么这个连接会暂停等待数据包找回，我们知道http2多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。
# 数组去重，不能用es6
# xss和csrf攻击
XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
1. 存储型 XSS 攻击
这种xss攻击一般都是黑客通过页面漏洞将脚本存入数据库中，然后用户访问到具有脚本的页面时，这个脚本会执行，用户受到攻击
2. 反射型 XSS 攻击
这种脚本一般都是伪装成链接的形式，用户将这个链接作为请求提交给服务器，然后服务器返回到浏览器端
3. 基于DOM的xss攻击
这种攻击一般是通过手段篡改页面内容
## 预防手段
- 服务器对输入脚本的内容进行过滤或者转码，react在虚拟dom转化时就有这部操作
- 利用csp，限制下载其他域的脚本资源
- cookie的httponly属性
csrf是跨站攻击，比如用户登录了一个页面，然后再去点击黑客的页面时，黑客的页面有一个img资源，而资源的链接是一个转账请求，浏览器会自动加载资源从而利用登录状态向登录的页面发起get请求，或者隐黑客的页面中有隐藏的表单，这时就会发起post的转账请求，或者引诱用户点击黑客的链接，而这个链接就是一个转账请求
## 预防手段
- cookie有一个属性是samesite，这个属性可以控制第三方请求已登录页面的资源时，是不可以带上cookie的
- http的origin和referer属性，浏览器可以通过这两个属性判断该请求是否是第三方站点请求的，origin是只带本域名，不带路径的
- 由于第三方请求本页面都会自动带上cookie，所以我们可以通过设置token判断登录状态，token是不会被自动带上的
# 进程和线程
线程是享用进程资源的最小单位，一个进程中可以有很多线程，他们共享进程中的数据，而js是单线程的，所以js会阻塞dom的生成，而css又会阻塞js的生成。浏览器最开始是单进程模式，这样倒是进程中有一个线程崩溃，整个进程都会崩溃，极其不稳定，而且浏览器需要向操作系统获取数据，这样会导致渲染线程有机可乘，因为都在一个进程中(安全沙箱最小保护单位是进程)，而多进程浏览器中的渲染进程会设置安全沙箱，称为渲染内核，而浏览器内核分为网络进程，浏览器进程和gpu进程，插件进程，这样会使得每个进程互不影响，若一个渲染进程卡死，其他渲染进程也安然无恙。渲染进程设置了安全沙箱之后，渲染进程读取cookie，缓存，网络请求和用户交互等功能都需要先由浏览器内核拿到，然后ipc通信传给渲染进程
# HTTPS加密
1. 首先浏览器向服务器发送一个client_random随机数和加密方法列表
2. 服务器接收到之后向浏览器返回所使用的加密方法和一个service_random随机数和数字证书(数字证书是CA机构通过服务器提供的信息和HASH算法生成信息摘要，而后CA通过私钥加密信息摘要形成密文数字签名)
3. 浏览器首先拿到数字证书(一般会返回这个网站的数字证书和CA数字证书)，通过其中返回的明文信息和对应的hash算法生成信息摘要A，而后通过CA数字证书中提供的公钥解密数字签名生成信息摘要B，此时比较两个信息摘要是否一致，若一致则证明目标服务器无误，而后根据返回的client_random和service_random还有返回的加密方法生成pre_moster，而后在传输给服务器时通过公钥加密
4. 服务器拿到加密后的密文后通过私钥解密，最后双方通过pre_moster，client_random,service_random加密生成moster_secret，然后通过最终的密钥加密传输的数据
# setTimeout和raF实现动画
CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行。而js动画如setTimeout,raF,由于setTimeout是宏任务，执行时间可能会被延时任务嵌套或者微任务所延误，不能和vsync时钟一致(显示器再执行完一帧后，会在下一帧执行前给gpu发送一个垂直同步信号，这个信号称为vsync)，而window.requestAnimationFrame回调函数的执行时机就是再vsync开始时，更能胜任动画工作
# OSI七层模型
7. 应用层 应用层给应用软件提供服务，并且规定通讯中的细节，而通讯另一方的就是表示层。 例如: HTTP， FTP, TELNET、SMTP
6. 表示层 表示层把应用层传来的信息转换为适合网络传输的格式，或者将下一层传来的数据转化为上一层能处理的格式。例如: SSL记录协议(为高层协议提供数据封装、压缩、加密等基本功能的支持),ASCII
5. 会话层 会话层负责连接和断开通信的连接, 以及数据的分割等数据传输相关的管理。例如：RPC，SSL握手协议(用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等)
4. 传输层 传输层起着可靠传输数据的作用，负责把数据发送到指定的端口，把传输的数据加工成数据包的形式进行传输。例如tcp,udp
3. 网络层 网络层负责将数据发送到对方主机中，两台主机可能有多条数据链路连接，而网络层则会挑选一条相对顺畅且更近的路径进行传输。IP协议通过不断转发数据到更近的地址，类似于火车中转。这一层的协议有IP,ICMP 
2. 数据链路层 该层负责物理层面上互连的节点之间的通信传输，并且将数据划分为具有意义的数据帧传送给对方。例如与1个以太网相连的两个节点间的通讯。常见的协议有 HDLC、PPP、SLIP 等。
1. 物理层 物理层通过数据的0,1转换成电信号或者光信号，通过光纤、双绞线甚至是无限电波等介质传输到指定的地址。而传输过程中的集线器、中继器、调制解调器等，也属于物理层的传输介质。
# V8如何执行一段js代码
1. v8会创建当前代码的执行上下文，若是全局代码则是全局执行上下文，若是函数内的代码则先创建全局上下文，在创建函数执行上下文
2. V8对js代码进行词法分析，将源码拆分成一个个最小单位的token，例如 var myName = 'abc'， 拆分为关键字var， 标识符myName,赋值运算符 =, 字符串'abc'
3. 第二阶段是语法分析，对一个个token根据语法规则转成ast语法树
4. 若碰到声明变量则分配内存，然后若是var放入变量环境，若是let，const放入词法环境，然后每一次遇到赋值，取值时，通过先查找词法环境，然后查找变量环境
5. 接着生成cpu可以执行的字节码
6. 然后进入执行阶段，解释器会逐条执行代码，但是如果是循环代码循环无限次，解释器要在执行时将代码编译N次，所以js引入及时编译器JIT， 如果当前代码被解释器判定执行了多次，会被判定为热点代码，JIT会把代码进行编译优化成机器码，然后就只需执行多次机器码，不需要多次编译，并且下一次执行这段代码会直接执行机器码
# 编译器和解释器
语言分为编译型语言和解释型语言。编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。
1. 在编译型语言的编译过程中，编译器会对代码进行词法分析和语法分析，生成AST语法树， 然后优化代码，生成机器码，编译成功后会生成一个可执行的文件
2. 在解释器语言的解释过程中， 解释器会对代码进行词法分期和语法分期， 生成AST语法树， 然后根据语法树生成字节码，最后通过字节码执行程序，输出结果
# 首屏渲染优化
1. cdn分发
2. 后端对高频接口设置缓存
3. 浏览器设置强缓存
4. 前端的资源动态加载：
a. 路由动态加载，最常用的做法，以页面为单位，进行动态加载。
b. 组件动态加载(offScreen Component)，对于不在当前视窗的组件，先不加载。
c. 图片懒加载(offScreen Image)，同上。值得庆幸的是，越来越多的浏览器支持原生的懒
   加载，通过给img标签加上loading="lazy来开启懒加载模式。
5. 减少请求的数量 这个优化在http1.1很有效，因为当时是串行传输，但是在http2.0效果不大
6. 图片设置
# 优化相关
首先我们需要了解项目的瓶颈所在，然后对症下药
1. 后端类型： 
- 如果是后端返回的数据过于冗余，减少返回的多余的字段
- 若是数据结构过于难以遍历，则优化数据结构，达到前端遍历数据时时间复杂度降低
- 后端数据增加gzip压缩， 服务器使用CDN加速
- 数据过大可以改成微服务，将大文件分为多个小文件，然后采用http2的多路复用来并行请求
2. 前端瓶颈： 
- 路由懒加载
- webpack构建采用tree sharking优化
- 减少hooks依赖所导致的不必要的渲染，通过把依赖放入redux中，然后通过store.getState()的方式，既解决了闭包陷阱的问题，也减少了函数的重新执行
- 尽量减少首屏的数据请求，一些隐藏的入口先暂不请求所需数据，展开再请求数据，尽量降低首屏的接口请求和不必要的渲染
- 通过节流和防抖的形式来限制一些前端频繁调接口
- 图片使用懒加载的形式，并且最好使用webp图片 (jpeg: 压缩体积，但是图片会受损,不支持透明 png: 体积相对较大，但是图片很清晰，支持透明，适合做logo webp: 压缩算法更优，并且提供无损和有损两种压缩方式，支持透明和转换)
- 多个dom渲染时使用虚拟滚动形式，只渲染视窗内的数据
- 浏览器的强缓存和协商缓存机制
- 服务端渲染(ssr)
- 脚本设置async/defer
- 事件委托
# webpack打包优化
- 使用高版本的 Webpack 和 Node.js
- 压缩代码
  webpack-paralle-uglify-plugin uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)terser-webpack-plugin 开启 parallel 参数
  通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。
- 图片压缩 image-webpack-loader
- Tree-Shaking
# 项目难点
1. 数据量巨大，改成懒加载模式
2. 懒加载模式下存在勾选用例批量操作，但是由于勾选目录或者子目录无法拿到用例，所以做成展开时自动计算用例和目录的id，维护了两个数组
# 封装一个组件需要注意什么？
- 1.数据从父组件传入（子组件本身尽量不要生产数据，如果需要生成数据，只能在组件内部进行使用，不要传递出去。）
- 对于通过props传入的参数，不建议对其进行操作，因为会同时修改父组件里面的数据（如果修改的话，控制台中也会报错的），如果需要修改数据，可以传递给父组件，让父组件去修改（在父组件中处理事件）。
# 页面卡顿了应该怎么做，如何判断
# 缓存位置
# 从网卡把数据包发送到服务器经历了什么
# dns查找规则
# encodeuri和encodeuricomponent的区别
encodeURI()和encodeURIComponent()方法都可以对URI（通用资源标识符）进行编码，以便发送给浏览器。
但它们编码的范围有所不用。

encodeURI()方法对uri进行完整的编码，并且不处理？和&这些符号，处理完整的uri
encodeURIComponent()方法会处理上述符号，处理uri的组件