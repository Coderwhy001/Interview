# 输入url到页面渲染做了什么？
1. 用户在地址栏输入url，这时浏览器进程会判断url是否完整，组装协议，而后通过ipc通信把完整的url传给网络进程
2. 首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。
3. 而后网络进程查看是否有dns缓存，如果没有就在dns系统查找对应的ip地址，如果是https，还会建立TLS连接
4. 接下来就是利用ip地址和服务器建立tcp连接， 连接建立之后，浏览器会构建请求行，请求头和请求体，并把该域名相关的cookie等信息添加到请求头中，发起http请求
5. 服务器接收请求之后，会返回响应数据并且发给网络进程，而后网络进程开始解析响应数据
6. 若状态码是301或302，则重定向到响应数据location页面，若是200则正常解析
7. 如果content-type是text/html的话，需要准备渲染进程，由于站点隔离，所以跟域名一样的页面会被放到同一个渲染进程，而如果一个页面存在不同站点的iframe或者新的页面根域名不同，也会被放到新的渲染进程中
8. 网络进程会把返回的html文档提交给渲染进程，若数据传输完毕，浏览器更新页面，url等状态
9. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
10. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
11. 创建布局树，并计算元素的布局信息。
12. 对布局树进行分层，并生成分层树。
13. 为每个图层生成绘制列表，并将其提交到合成线程。 
14. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
15. 合成线程发送绘制图块命令DrawQuad给浏览器进程。 
16. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
# transform为什么相比position更不耗性能
因为transform是触发合成，position触发重排

# 尾递归优化
若函数的最后一步操作是调用函数，则将这种递归称为尾递归，目前大部分编译器都对尾递归有优化，会将当前函数的执行上下文从调用栈中清除然后创建下一个执行上下文，不会造成栈溢出
# let 和var区别
let会在创建时被提升，这时会在词法环境创建这个变量，但是不会初始化，所以处于暂时性死区， var的创建和初始化都被提升，复制undefined，并且在编译时就会被创建到编译环境中，只要处于函数的执行上下文，先访问词法环境再访问变量环境
# 闭包
当一个函数返回另一个函数，而返回的函数又引用到了第一个函数的变量时，就形成了闭包，这时外层函数执行完毕后执行上下文会从调用栈中销毁，但是所引用到的变量会形成闭包，所以当返回的函数中需要改变引用的变量时，会改变闭包中的变量。闭包产生的内存对象地址存储在栈中，数据存储在堆中，当函数销毁时不会跟着销毁，因为还有引用。
# setTimeOut中的回调函数的this是指向windows对象的
# 页面渲染性能优化策略
1. 减少 JavaScript 脚本执行时间
- 可以将一个很大的任务分成多个小任务
- 使用web workers，web workers是运行在主线程之外的一个线程，web workers没有DOM和CSSOM的环境，所以可以把一些与dom无关且不耗时的任务放在这里运行
2. 避免强制布局或者布局抖动
由于浏览器会对一系列重拍操作添加到队列中，队列满了会将其一次性执行，这样避免多次重拍操作，但是如果我们在进行了重排操作后需要获取位置信息如offset， 这时浏览器判定队列有操作，需要清空队列来获取正确的信息，这样会导致多次重排，影响页面性能
3. 合理利用 CSS 合成动画
尽量避免用js实现动画，因为合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。
4. 避免频繁的垃圾回收
我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。
# http1.1和2.0的区别
1. http1.1虽然实现了持久化连接，6个tcp连接和cdn域名分片，但是有几大问题
- tcp连接慢。慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。
- 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。
- 头部阻塞。持久连接可以公用一个管道，但是一个tcp中前一个请求网络阻塞了，后面那个需要等待，很耗时间
2. http2的改进
- 多路复用： 一个域名只是用一个tcp连接，每个请求多复用这个tcp连接，这样不用重复的建立tcp连接，只连接一次，并且解决了头部阻塞和共享带宽的问题
- 可以设置请求的优先级：由于服务器是按照请求的顺序回复数据，有些重要的数据会推迟，所以设置优先级使他第一时间到达
- 服务器推送：服务器支持像浏览器推送数据
- 头部压缩： 如果http发现多个请求的头部大部分内容一致，可以将其省略，这样只保留不一致的内容
但是由于http只有一个tcp连接，如果这个tcp连接出现了数据包的丢失，那么这个连接会暂停等待数据包找回，我们知道http2多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。
# 数组去重，不能用es6
# xss和csrf攻击
XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
1. 存储型 XSS 攻击
这种xss攻击一般都是黑客通过页面漏洞将脚本存入数据库中，然后用户访问到具有脚本的页面时，这个脚本会执行，用户受到攻击
2. 反射型 XSS 攻击
这种脚本一般都是伪装成链接的形式，用户将这个链接作为请求提交给服务器，然后服务器返回到浏览器端
3. 基于DOM的xss攻击
这种攻击一般是通过手段篡改页面内容
## 预防手段
- 服务器对输入脚本的内容进行过滤或者转码，react在虚拟dom转化时就有这部操作
- 利用csp，限制下载其他域的脚本资源
- cookie的httponly属性
csrf是跨站攻击，比如用户登录了一个页面，然后再去点击黑客的页面时，黑客的页面有一个img资源，而资源的链接是一个转账请求，浏览器会自动加载资源从而利用登录状态向登录的页面发起get请求，或者隐黑客的页面中有隐藏的表单，这时就会发起post的转账请求，或者引诱用户点击黑客的链接，而这个链接就是一个转账请求
## 预防手段
- cookie有一个属性是samesite，这个属性可以控制第三方请求已登录页面的资源时，是不可以带上cookie的
- http的origin和referer属性，浏览器可以通过这两个属性判断该请求是否是第三方站点请求的，origin是只带本域名，不带路径的
- 由于第三方请求本页面都会自动带上cookie，所以我们可以通过设置token判断登录状态，token是不会被自动带上的
# 进程和线程
线程是享用进程资源的最小单位，一个进程中可以有很多线程，他们共享进程中的数据，而js是单线程的，所以js会阻塞dom的生成，而css又会阻塞js的生成。浏览器最开始是单进程模式，这样倒是进程中有一个线程崩溃，整个进程都会崩溃，极其不稳定，而且浏览器需要向操作系统获取数据，这样会导致渲染线程有机可乘，因为都在一个进程中(安全沙箱最小保护单位是进程)，而多进程浏览器中的渲染进程会设置安全沙箱，称为渲染内核，而浏览器内核分为网络进程，浏览器进程和gpu进程，插件进程，这样会使得每个进程互不影响，若一个渲染进程卡死，其他渲染进程也安然无恙。渲染进程设置了安全沙箱之后，渲染进程读取cookie，缓存，网络请求和用户交互等功能都需要先由浏览器内核拿到，然后ipc通信传给渲染进程
# HTTPS加密
1. 首先浏览器向服务器发送一个client_random随机数和加密方法列表
2. 服务器接收到之后向浏览器返回所使用的加密方法和一个service_random随机数和数字证书(数字证书是CA机构通过服务器提供的信息和HASH算法生成信息摘要，而后CA通过私钥加密信息摘要形成密文数字签名)
3. 浏览器首先拿到数字证书(一般会返回这个网站的数字证书和CA数字证书)，通过其中返回的明文信息和对应的hash算法生成信息摘要A，而后通过CA数字证书中提供的公钥解密数字签名生成信息摘要B，此时比较两个信息摘要是否一致，若一致则证明目标服务器无误，而后根据返回的client_random和service_random还有返回的加密方法生成pre_moster，而后在传输给服务器时通过公钥加密
4. 服务器拿到加密后的密文后通过私钥解密，最后双方通过pre_moster，client_random,service_random加密生成moster_secret，然后通过最终的密钥加密传输的数据
# setTimeout和raF实现动画
CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行。而js动画如setTimeout,raF,由于setTimeout是宏任务，执行时间可能会被延时任务嵌套或者微任务所延误，不能和vsync时钟一致(显示器再执行完一帧后，会在下一帧执行前给gpu发送一个垂直同步信号，这个信号称为vsync)，而window.requestAnimationFrame回调函数的执行时机就是再vsync开始时，更能胜任动画工作
# OSI七层模型
7. 应用层 应用层给应用软件提供接口，以设置与另一应用软件通信.例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。
6. 表示层 把数据转换为能与接收者系统格式兼容并适合传输的格式
5. 会话层 负责在数据传输中设置和维护两台计算机之间的通信
4. 传输层 把传输表头加工成数据包的形式传输，传输表头包括协议等信息。 例如：tcp， udp
3. 网络层 决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。
2. 数据链路层 负责网络寻址、错误侦测和改错 例如： 以太网，WIFI
1. 物理层 在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。 例如：网线，网卡